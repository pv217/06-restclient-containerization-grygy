# 06 - RestClient, Containerization

## RestClient

Quarkus provides a simple way to create a REST client for other services. Using the REST Client Reactive is as simple as creating an interface using the proper Jakarta REST and MicroProfile annotations.

The interface method gives us access to HTTP communication with other services. Thus, we can use this interface in different parts of our application.

#### Example

```java
@Path("/extensions") // Base path for the REST service
@RegisterRestClient(configKey = "extensions-api") // Config key for the REST client that will be used in the application.properties
public interface ExtensionsService {

    @GET // HTTP method
    @Path("/{id}") // Path for the method
    Uni<Set<Extension>> getById(@PathParam("id") String id); // Method for getting extensions by id. Translates to HTTP GET /extensions/{id}
}
```

## Containerization

Containerization is a lightweight alternative to full machine virtualization that involves encapsulating an application in a container with its own operating environment. Containers are isolated from one another and bundle their own software, libraries, and configuration files.

### Why is containerization important?

- **Consistency** - Containers ensure that the software runs in the same environment, regardless of where it is deployed.
- **Isolation** - Containers are isolated from each other and the host system.
- **Scalability** - Containers can be easily scaled up or down.

### Docker

Docker is a platform for developing, shipping, and running applications using containerization. It allows you to package your application and its dependencies into a container that can run on any environment.

#### Docker image

A Docker image is a file that contains all the necessary dependencies and configurations to run a container. It is a lightweight, standalone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and configuration files.

#### Docker container

A container is a runtime instance of a Docker image. This means it is a running instance of the containerized application. Containers can be run, started, stopped, moved, and deleted. When containers are deleted, any data that is not in a volume is lost.

#### Docker volume

A Docker volume is a directory that is outside the lifecycle of the container. It is used to persist data generated by and used by Docker containers.

#### Docker engine

The Docker engine is the core of Docker. It is a client-server application that builds and runs containers.

#### Dockerhub

Dockerhub is a cloud-based registry service that allows you to select images from a wide range of applications and base images. You can also upload your own images to the registry.

#### Dockerfile

A dockerfile is a text document that contains all the commands and application configuration to assemble an image. Docker reads the Dockerfile and executes the commands in the file to build the image.

```Dockerfile
# Use the official image as a base image that our application will run on
FROM registry.access.redhat.com/ubi8/openjdk-21:1.19

# Set environment variables
ENV LANGUAGE='en_US:en'


# Copy the application jar file to the container
COPY --chown=185 target/quarkus-app/lib/ /deployments/lib/
COPY --chown=185 target/quarkus-app/*.jar /deployments/
COPY --chown=185 target/quarkus-app/app/ /deployments/app/
COPY --chown=185 target/quarkus-app/quarkus/ /deployments/quarkus/

# Expose the port that the application will run on
EXPOSE 8077
# Set the user that will run the application
USER 185
# Set up more environment variables that will be used to run the application
ENV JAVA_OPTS_APPEND="-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager"
ENV JAVA_APP_JAR="/deployments/quarkus-run.jar"

# Run the application
ENTRYPOINT [ "/opt/jboss/container/java/run/run-java.sh" ]
```

#### What does the Dockerfile do?

- It uses the official image as a base image on which our application will run.
- It can build the application from the source code.
- It copies the application jar file and sends it to the container.
- It exposes the port on which the application will run.
- It sets up environment variables that will be used to run the application.
- It runs the application.

#### How to build a docker image?

First, we need to build the docker image for the application. We can do it using the `docker build` command.

```bash
# Choose the Dockerfile to use and tag the image with a name
docker build -f src/main/docker/Dockerfile.jvm -t quarkus/baggage-service-jvm .
```

#### How to run the docker container?

After building the image, we can run the container using the `docker run` command.

```bash
# Maps the port 8077 from the container to the port 8077 on the host
docker run -i --rm -p 8077:8077 quarkus/baggage-service-jvm
```

This was a brief introduction to docker and containerization. For more information, check the [official documentation](https://docs.docker.com/).

### Docker compose

Docker compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application's services. Then, with a single command, you create and start all the services from your configuration.

#### What can docker compose do?

- Define and run multi-container applications with Docker. Eg. run a database and a web application in separate containers.
- Set up networking between containers.
- Set up volumes for persistent data.
- Run a multi-container application on a host.

#### Docker compose file

Docker compose file is a YAML file that defines the services, networks, and volumes for a multi-container Docker application. The default name for the file is `docker-compose.yml`.

#### Example

```yaml
version: '3.8'
services: # List of services that will be run
  baggage-service: # Name of the service
    build: # Build the service from the Dockerfile
      context: ./baggage-service # Path to the service
      dockerfile: src/main/docker/Dockerfile.jvm # Path to the Dockerfile
    ports: # Ports that will be mapped and exposed to the host
      - "8077:8077" # Maps the port 8077 from the container to the port 8077 on the host
    environment: # Environment variables that will be used in the service
      QUARKUS_DATASOURCE_DB_KIND: postgresql # Variables used in our case in application.properties
      QUARKUS_DATASOURCE_USERNAME: user 
      QUARKUS_DATASOURCE_PASSWORD: password
      QUARKUS_DATASOURCE_REACTIVE_URL: vertx-reactive:postgresql://baggage-db:5432/baggage-database # URL for the database using docker network alias
    depends_on: # Services that this service depends on
      - baggage-db # Name of the database service
    networks: # Networks that the service will be connected to
      - app-network # Name of the network

  baggage-db: # Name of the database service
    image: postgres:16.2 # Image that will be used for the database
    environment: # Environment variables that will be used in the service
      POSTGRES_DB: baggage-database
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes: # Volumes that will be used in the service
      - baggage-db-data:/var/lib/postgresql/data # Volume for the database data with path to the data
    networks:
      - app-network

networks: # Networks that will be used in the services
  app-network: # Name of the network
    driver: bridge # Type of the network

volumes: # Volumes that will be used in the services
  baggage-db-data: # Name of the volume
```

## State of the project

- There is a new `baggage-service` is a REST service for tracking baggage running on port 8077.
    - It supports CRUD operations for baggage along with claiming and marking baggage as lost.
    - You can also retrieve baggage for a passenger based on passenger id.
    - Check `BaggageResource` for more details.

## Tasks

### 0. Running docker

Install [Docker desktop](https://docs.docker.com/engine/install/) or another docker client. Our test database will run in the docker
container.

### 1. Define `BaggageClientResource` in `passenger-service`

#### 1.1. Run `baggage-service`

Run the `baggage-service` in dev mode. Then check the swagger UI at http://localhost:8077/q/swagger-ui.

Examine the *Get baggage by passenger id* endpoint. We will use it in `passenger-service`.

#### 1.2. Define `BaggageClientResource` interface

In `passenger-service` define a new interface `BaggageClientResource`. This interface will represent the REST client for the Baggage service.

1. Create a config key for the baggage service URL in `application.properties` file. See todo in `application.properties` file.
2. Follow the TODOs in `BaggageClientResource` interface.

#### 1.3. Use `BaggageClientResource` in `PassengerService`

Now, we want to use the `BaggageClientResource` in `PassengerService` to retrieve baggage for a passenger. Go to `PassengerService` and implement the `getBaggageForPassenger` method.

#### 1.4. Test it

1. In Swagger, create a passenger in `passenger-service` and then create a baggage for the passenger in `baggage-service`.
2. Try to get the baggage for his passenger using the `GET /passenger/{passengerId}/baggage` endpoint.

### 2. Create docker-compose file for baggage-service

Quarkus already created Dockerfiles for us, so we can easily use them in Docker compose and run the services in containers.

#### 2.1. Package the application

We need to create a jar file for the `baggage-service` to be able to run it in a docker container. Run the following
command in `baggage-service` directory:

```bash
./mvnw package
```

It should create a `target/quarkus-app` directory with the jar file.

#### 2.2. Run pure docker container

Now try to run the `baggage-service` in a docker container. We already have Dockerfile.jvm created for us by quarkus
in `./src/main/docker` directory.

1. Build the docker image:

   ```bash
   docker build -f src/main/docker/Dockerfile.jvm -t quarkus/baggage-service-jvm .
   ```

2. Run the docker container:
    - Don't forget to kill the running `baggage-service` otherwise the port 8077 will be already in use.

   ```bash
   # Maps the port 8077 from the container to the port 8077 on the host
   docker run -i --rm -p 8077:8077 quarkus/baggage-service-jvm
   ```

3. Go to http://localhost:8077/q/swagger-ui and check if the service is running. (database is not running, so we can't create baggage yet)

#### 2.3. Create docker compose configuration

Now, we have a working docker container for `baggage-service`. Let's make a docker-compose configuration with db connection as well.

Check the `application.properties` file in `baggage-service` to see what environment variables are needed for the service to run.

In `baggage-service` go to `docker-compose.yml` file and create a configuration for baggage-service. See TODOs in the file.

#### 2.4. Run the docker-compose

First, we need to build the docker image for the `baggage-service`:

```bash
docker compose build
```

Now, let's use the docker compose to run both `baggage-service` and `database` in a single command.

```bash
docker compose up
```

Check if the `baggage-service` is running on http://localhost:8077/q/swagger-ui and try to create and retrieve baggage.


### 3. Create docker-compose file for the whole project

#### 3.1. Build other services

Go to `flight-service` and `passenger-service` and make a production build of the application.
```bash
# Run in both directories
./mvnw package
```

#### 3.2. Add missing configuration to `docker-compose.yml`

In the root of the project, you can find the `docker-compose.yml` file. It already contains configuration baggage service and database. Now, we need to add configuration for `flight-service` and `passenger-service`.

Follow the TODOs in the file. Don't forget to set up environment variables for the services. Examine `application.properties` files in the passenger and flight services to see what environment variables are needed.

#### 3.3. Run the docker-compose

Now, we have a docker-compose configuration for the whole project. Let's run it.

```bash
docker compose up
```

Check if everything is running.

### 4. Verify if everything is working

1. With every service running in docker containers, try to create a flight, create a passenger, and create baggage.
2. Cancel the flight and see if gRPC communication is working.
3. Try to retrieve baggage for a passenger in passenger service.

### 5. Submit the solution

1. Finish the tasks
2. Push the changes to the main branch
3. GitHub Classroom automatically prepared a feedback pull request for you
4. Go to the repository on GitHub and find the feedback pull request
5. Set label to "Submitted"
6. GitHub Actions will run basic checks for your submission
7. Teacher will evaluate the submission as well and give you feedback

## Hints

- Check docker-compose in flight-service for inspiration.

## Troubleshooting

- Check if your docker engine is running.

## Further reading

- https://quarkus.io/guides/rest-client-reactive